<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .draggable {
            cursor: move;
            user-select: none;
        }
    </style>
</head>

<body>
    <div id="list">
        <div class="draggable">A</div>
        <div class="draggable">B</div>
        <div class="draggable">C</div>
        <div class="draggable">D</div>
        <div class="draggable">E</div>
    </div>

    <script>
        let draggingEle;
        let x = 0;
        let y = 0;
        let placeholder;
        let isDraggingStarted = false;


        const mouseDownHandler = (e) => {
            draggingEle = e.target;

            const rect = draggingEle.getBoundingClientRect();
            x = e.paseX - rect.left;
            y = e.paseY - rect.top;

            document.addEventListener('mousemove', mouseMoveHandler);
            document.addEventListener('mouseup', mouseUpHandler);
        };

        const mouseMoveHandler = (e) => {
            const draggingRect = draggingEle.getBoundingClientRect();

            const prevEle = draggingEle.previousElementSibling;
            const nextEle = placeholder.nextElementSibling;

            if (!isDraggingStarted) {
                // Update the flag
                isDraggingStarted = true;

                // Let the placeholder take the height of dragging element
                // So the next element won't move up
                placeholder = document.createElement('div');
                placeholder.classList.add('placeholder');
                draggingEle.parentNode.insertBefore(
                    placeholder,
                    draggingEle.nextSibling
                );

                // Set the placeholder's height
                placeholder.style.height = `${draggingRect.height}px`;
            }
            draggingEle.style.position = 'absolute';
            draggingEle.style.top = `${e.paseY - y}px`;
            draggingEle.style.left = `${e.paseX - x}px`;

            // User moves item to the top
            if (prevEle && isAbove(draggingEle, prevEle)) {
                // The current order    -> The new order
                // prevEle              -> placeholder
                // draggingEle          -> draggingEle
                // placeholder          -> prevEle
                swap(placeholder, draggingEle);
                swap(placeholder, prevEle);
                return;
            }

            // User moves the dragging element to the bottom
            if (nextEle && isAbove(nextEle, draggingEle)) {
                // The current order    -> The new order
                // draggingEle          -> nextEle
                // placeholder          -> placeholder
                // nextEle              -> draggingEle
                swap(nextEle, placeholder);
                swap(nextEle, draggingEle);
            }
        };

        const mouseUpHandler = (e) => {
            // Remove the placeholder
            placeholder && placeholder.parentNode.removeChild(placeholder);
            // Reset the flag
            isDraggingStarted = false;

            draggingEle.style.removeProperty('absolute');
            draggingEle.style.removeProperty('top');
            draggingEle.style.removeProperty('left');

            x = null;
            y = null;
            draggingEle = null;

            document.removeEventListener('mousemove', mouseMoveHandler);
            document.removeEventListener('mousemove', mouseUpHandler);
        };

        const list = document.getElementById('list');

        [].slice.call(list.querySelectorAll('.draggable')).forEach(item => {
            item.addEventListener('mousedown', mouseDownHandler);
        });

        const isAbove = function (nodeA, nodeB) {
            // Get the bounding rectangle of nodes
            const rectA = nodeA.getBoundingClientRect();
            const rectB = nodeB.getBoundingClientRect();

            return rectA.top + rectA.height / 2 < rectB.top + rectB.height / 2;
        };

        const swap = function (nodeA, nodeB) {
            const parentA = nodeA.parentNode;
            const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;

            // Move `nodeA` to before the `nodeB`
            nodeB.parentNode.insertBefore(nodeA, nodeB);

            // Move `nodeB` to before the sibling of `nodeA`
            parentA.insertBefore(nodeB, siblingA);
        };

    </script>
</body>

</html>